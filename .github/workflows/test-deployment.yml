name: Verify that the current chart can be deployed locally on minikube

env:
  HELM_VERSION: 3.7.0
  IMAGE_REGISTRY: operatorservice.azurecr.io
  OP_CHART_DIRECTORY: ./chart/op-svc-jenkins # should match repo's directory structure
  CRS_CHART_DIRECTORY: ./chart/op-svc-jenkins-crs # should match repo's directory structure
  OPERATOR_NAMESPACE: operator
  JENKINS_NAMESPACE: jenkins # should match 'jenkinsNamespace' field value in operator-service values.yaml

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]
  workflow_dispatch:

jobs:
    verify-that-chart-can-be-deployed:
      name: test that current chart can be deployed locally on minikube
      runs-on: ubuntu-latest

      steps:
        - uses: actions/checkout@v2
          with:
            fetch-depth: 0
          name: checkout repo

        - name: Install helm
          run: |
            make helm-install HELM_VERSION=$HELM_VERSION

        - name: Prepare and start a local Minikube cluster
          run: |
            sudo apt-get update
            sudo apt-get install socat
            sudo mkdir -p $HOME/.kube $HOME/.minikube
            sudo chown -R $USER $HOME/.kube $HOME/.minikube
            make minikube-start MINIKUBE_DRIVER='docker' MEMORY_AMOUNT=4096 CPUS_NUMBER=2

        - name: Create namespaces for Jenkins and Operator
          run: |
            kubectl create ns $JENKINS_NAMESPACE
            kubectl create ns $OPERATOR_NAMESPACE

        - name: Create secret with data for accessing the image registry
          run: |
            kubectl create secret docker-registry token \
            --namespace $OPERATOR_NAMESPACE \
            --docker-server=$IMAGE_REGISTRY \
            --docker-username=${{ secrets.DEPLOYMENT_TEST_WORKFLOW_CUSTOMER_NAME }} \
            --docker-password=${{ secrets.DEPLOYMENT_TEST_WORKFLOW_ACR_PASSWORD }}

        - name: Create license secret
          run: |
            cat <<EOF | kubectl apply -f -
            apiVersion: v1
            kind: Secret
            metadata:
              name: license
              namespace: $OPERATOR_NAMESPACE
            stringData:
              clientName: ${{ secrets.DEPLOYMENT_TEST_WORKFLOW_CUSTOMER_NAME }}
              licenseKey: ${{ secrets.DEPLOYMENT_TEST_WORKFLOW_LICENSE_SECRET_KEY }}
            EOF

        - name: Install operator-service chart
          run: |
            helm install operator-service $OP_CHART_DIRECTORY -f $OP_CHART_DIRECTORY/values.yaml -n $OPERATOR_NAMESPACE

        - name: Verify that Operator is up and running
          run: |
            for i in {0..90}
            do
              sleep 2

              PHASE=$(kubectl get pod -n $OPERATOR_NAMESPACE -l app.kubernetes.io/name=op-svc-jenkins -o jsonpath="{.items[0].status.phase}" --ignore-not-found)
              READY=$(kubectl get pod -n $OPERATOR_NAMESPACE -l app.kubernetes.io/name=op-svc-jenkins -o jsonpath="{.items[0].status.containerStatuses[0].ready}" --ignore-not-found)

              if [ -z "$PHASE" ]; then
                echo "Operator pod hasn't yet been created, waiting another 2 secs"
              else
                echo "Operator pod phase: $PHASE"
                echo -e "Operator pod ready: $READY\n"
              fi

              if [[ $PHASE == Running && $READY == true ]]; then
                break
              fi
            done

            if [[ $PHASE == Running && $READY == true ]]; then
              echo "Operator should be fully up and running! Here are the logs from the Operator pod:"
              kubectl logs -n operator -l app.kubernetes.io/name=op-svc-jenkins
            else
              echo "Operator didn't get Running and Ready within 3 minutes. Good luck with troubleshooting."

              echo "Here are the logs from Operator pod:"
              kubectl logs -n operator -l app.kubernetes.io/name=op-svc-jenkins

              echo "Here are the events from Operator namespace:"
              kubectl get events -n $OPERATOR_NAMESPACE --sort-by='.lastTimestamp'
            fi

        - name: Install crs chart
          run: |
            helm install operator-service-crs $CRS_CHART_DIRECTORY -f $CRS_CHART_DIRECTORY/values.yaml -n $JENKINS_NAMESPACE

        - name: Verify that Jenkins is running and ready
          run: |
            for i in {0..60}
            do
              sleep 5

              PHASE=$(kubectl get pod -n $JENKINS_NAMESPACE -l operator-service.com/kind=Jenkins -o jsonpath="{.items[0].status.phase}" --ignore-not-found)
              READY=$(kubectl get pod -n $JENKINS_NAMESPACE -l operator-service.com/kind=Jenkins -o jsonpath="{.items[0].status.containerStatuses[0].ready}" --ignore-not-found)

              if [ -z "$PHASE" ]; then
                echo "Jenkins pod hasn't yet been created, waiting another 5 secs"
              else
                echo "Jenkins pod phase: $PHASE"
                echo -e "Jenkins is ready: $READY\n"
              fi

              if [[ $PHASE == Running && $READY == true ]]; then
                break
              fi
            done

            if [[ $PHASE == Running && $READY == true ]]; then
              echo "Jenkins should be fully up and running! Here are the logs from Jenkins pod:"
              kubectl logs -n $JENKINS_NAMESPACE -l operator-service.com/kind=Jenkins
            else
              echo "Jenkins didn't get Running and Ready within 5 minutes. Good luck with troubleshooting."

              echo "Here are the logs from Jenkins pod:"
              kubectl logs -n $JENKINS_NAMESPACE -l operator-service.com/kind=Jenkins

              echo "Here are the logs from initial-config container:"
              kubectl logs -n $JENKINS_NAMESPACE -l operator-service.com/kind=Jenkins -c initial-config

              echo "Here are the logs from jenkins-controller container:"
              kubectl logs -n $JENKINS_NAMESPACE -l operator-service.com/kind=Jenkins -c jenkins-controller

              echo "Here are the logs from operator:"
              kubectl logs -n operator -l app.kubernetes.io/name=op-svc-jenkins

              echo "Here are the events from Jenkins namespace:"
              kubectl get events -n $JENKINS_NAMESPACE --sort-by='.lastTimestamp'

              echo "Here are the events from Operator namespace:"
              kubectl get events -n $OPERATOR_NAMESPACE --sort-by='.lastTimestamp'

              exit 1
            fi
